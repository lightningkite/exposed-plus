# Exposed Plus

A Kotlin Symbol Processor combined with a runtime to make using Exposed feel extremely native to Kotlin

## Design Principles

- Everything should be done "the Kotlin way".
  - Match the API for collections as closely as possible
  - Use `data class`es where possible
  - Typing must be helpful throughout the whole system
- Fast queries - don't do any joins that aren't explicitly requested.

## A delicious sample

The example below is *currently working* and requires *no extra code to function*, just the use of the KSP dependency and runtime dependency.

```kotlin
@TableName
data class Employee(
  @PrimaryKey @AutoIncrement val id: Long = -1,
  val name: String,
  @ReverseName("manages") val manager: EmployeeKey? = null  // <- EmployeeKey is autogenerated from this class
) {
  companion object
}

/* Several classes will be generated based on the above, including something like this:
data class EmployeeKey(
    val id: Long,
) {
  val value: Employee by lazy {...}  // Accessing this will make a call to the database unless it's prefetched
}
 */

fun test() {
  val db = Database.connect("jdbc:h2:mem:test", driver = "org.h2.Driver")
  transaction {
    SchemaUtils.create(Employee.table)  // Table is autogenerated and added as an extension to the companion
    
    // Insert some employees
    val bobsKey: EmployeeKey = Employee.table.insertAndGetKey(Employee(
      name = "Bob"
    ))
    val bob: Employee = bobsKey.value  // Lazily fetches the value the key points to
    val bill = Employee.table.insertAndGetKey(Employee(
      name = "Bill",
      manager = bob.key  // Autogenerated extension function to get an EmployeeKey
    )).value
    val beth = Employee.table.insertAndGetKey(Employee(
      name = "Beth",
      manager = bob.key
    )).value
    val brad = Employee.table.insertAndGetKey(Employee(
      name = "Brad",
      manager = beth.key
    )).value
    
    // Print every employee
    Employee.table.all().forEach { it: Employee ->
      println(it)
    }
    
    // Get the employee who has no manager, or more specifically, Bob.
    val personInCharge = Employee.table.all()
      .filter { it.manager.id eq null }
      .single()
    
    // Get every employee directly under Bob.
    // Employee.manages is autogenerated due to the @ReverseName annotation
    val seconds: List<Employee> = personInCharge.manages.toList()

    // Get the employees under other employees named Beth.
    // This creates a join for you.
    val peopleWhoReportToABeth = Employee.table.all()
      .filter { it.manager.value.name eq "Beth" }
      .toList()
    
    // Get each employee with their manager in one SQL query
    Employee.table.all().prefetch { it.manager }.forEach { it: Employee ->
      // Accessing it.manager.value doesn't make a query because we already have the data from the prefetch
      println("Hi, my name is ${it.name} and my boss is ${it.manager.value.name}")
    }
  }
}
```

## How does it work?

A combination of annotations, Kotlin Symbol Processing, and some new classes and interfaces.

## How do I use it?

It's not quite ready yet, but I'm taking feedback and ideas for the API.  It is functional but not published.

## Features

- Automatically generates your Exposed tables for you
- Automatically generates a key class for every table, allowing you to have typed foreign keys
- An explicit boundary line for when you do and don't have joins on a request
- Create, update, and query objects as data classes
- Query conditions with joins
- Joins are reused where possible

### Planned

- Automatically generated migrations in a method similar to Django
- Even more support for reverse relations
- A sibling package that allows you to conveniently expose tables as REST endpoints with security rules
- 